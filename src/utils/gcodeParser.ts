import type { FilamentType, Asset } from '../types';

export interface GcodeParseResult {
  filamentGrams: number | null;
  printTimeHours: number | null;
  filamentType: string | null;
  filamentVendor: string | null;
  filamentSettingsId: string | null; // e.g. "Bambu PETG HF @BBL H2S" — more specific than filamentType
  slicer: 'bambu' | 'prusa' | 'cura' | 'orca' | 'superslicer' | 'ideamaker' | 'unknown';
  // Raw parsed values for display
  rawFilamentLength?: number | null; // mm
  rawPrintTimeString?: string | null;
}

// Detect which slicer generated the G-code
function detectSlicer(text: string): GcodeParseResult['slicer'] {
  // Order matters: OrcaSlicer is based on BambuStudio, check specific first
  if (/; generated by OrcaSlicer/i.test(text) || /OrcaSlicer/i.test(text)) return 'orca';
  if (/; generated by SuperSlicer/i.test(text)) return 'superslicer';
  if (/; generated by PrusaSlicer/i.test(text)) return 'prusa';
  if (/; BambuStudio/i.test(text) || /; HEADER_BLOCK_START/i.test(text)) return 'bambu';
  if (/;Generated with Cura_SteamEngine/i.test(text) || /;FLAVOR:/i.test(text)) return 'cura';
  if (/;Generated by ideaMaker/i.test(text)) return 'ideamaker';
  return 'unknown';
}

// Parse time strings like "1d 10h 22m 57s", "1h 23m 45s", "47m 27s", "6m 39s"
function parseTimeString(timeStr: string): number | null {
  const days = timeStr.match(/(\d+)d/);
  const hours = timeStr.match(/(\d+)h/);
  const minutes = timeStr.match(/(\d+)m(?!s)/); // "m" but not "ms"
  const seconds = timeStr.match(/(\d+)s/);

  let totalHours = 0;
  let foundAny = false;

  if (days) { totalHours += parseInt(days[1]) * 24; foundAny = true; }
  if (hours) { totalHours += parseInt(hours[1]); foundAny = true; }
  if (minutes) { totalHours += parseInt(minutes[1]) / 60; foundAny = true; }
  if (seconds) { totalHours += parseInt(seconds[1]) / 3600; foundAny = true; }

  return foundAny ? Math.round(totalHours * 100) / 100 : null;
}

// Convert filament length (mm) to grams using diameter and density
// Default: 1.75mm PLA with density 1.24 g/cm³
function filamentLengthToGrams(
  lengthMm: number,
  diameterMm: number = 1.75,
  densityGCm3: number = 1.24
): number {
  const radiusCm = (diameterMm / 2) / 10;
  const lengthCm = lengthMm / 10;
  const volumeCm3 = Math.PI * radiusCm * radiusCm * lengthCm;
  return Math.round(volumeCm3 * densityGCm3 * 100) / 100;
}

// Material density lookup (g/cm³) for length-to-weight conversion
function getMaterialDensity(filamentType: string | null): number {
  if (!filamentType) return 1.24; // PLA default
  const type = filamentType.toUpperCase();
  if (type.includes('PLA')) return 1.24;
  if (type.includes('PETG') || type.includes('PET')) return 1.27;
  if (type.includes('ABS')) return 1.04;
  if (type.includes('ASA')) return 1.07;
  if (type.includes('TPU')) return 1.21;
  if (type.includes('PA') || type.includes('NYLON')) return 1.14;
  if (type.includes('PC')) return 1.20;
  if (type.includes('PVA')) return 1.23;
  if (type.includes('PPS')) return 1.35;
  if (type.includes('PPA')) return 1.18;
  return 1.24; // Default to PLA density
}

// Parse PrusaSlicer / SuperSlicer / OrcaSlicer format
// These all use the same PrusaSlicer-derived comment format
function parsePrusaStyle(text: string): Partial<GcodeParseResult> {
  const result: Partial<GcodeParseResult> = {};

  // Filament used in grams: "; filament used [g] = 24.06"
  const gramsMatch = text.match(/;\s*filament used \[g\]\s*=\s*([\d.]+)/);
  if (gramsMatch) {
    result.filamentGrams = parseFloat(gramsMatch[1]);
  }

  // Filament used in mm (fallback if grams not available): "; filament used [mm] = 52880.9"
  if (!result.filamentGrams) {
    const mmMatch = text.match(/;\s*filament used \[mm\]\s*=\s*([\d.]+)/);
    if (mmMatch) {
      result.rawFilamentLength = parseFloat(mmMatch[1]);
    }
  }

  // Print time: "; estimated printing time (normal mode) = 1h 23m 45s"
  const timeMatch = text.match(/;\s*estimated printing time \(normal mode\)\s*=\s*(.+)/);
  if (timeMatch) {
    result.rawPrintTimeString = timeMatch[1].trim();
    result.printTimeHours = parseTimeString(timeMatch[1]);
  }

  // Filament type: "; filament_type = PLA" or "; filament_type = PLA;PETG" (multi-material)
  const typeMatch = text.match(/;\s*filament_type\s*=\s*([^\n;]+)/);
  if (typeMatch) {
    result.filamentType = typeMatch[1].trim();
  }

  // Filament vendor: "; filament_vendor = Bambu Lab" or '; filament_vendor = "Bambu Lab";"Bambu Lab"'
  const vendorMatch = text.match(/;\s*filament_vendor\s*=\s*"?([^";\n]+)"?/);
  if (vendorMatch) {
    result.filamentVendor = vendorMatch[1].trim();
  }

  return result;
}

// Parse Bambu Studio format
// Uses a mix of PrusaSlicer-style and Bambu-specific comments
// Bambu header uses ": " (colon-space) separators in the HEADER_BLOCK, e.g.:
//   ; total estimated time: 8h 40m 22s
//   ; total filament weight [g] : 433.16
//   ; total filament length [mm] : 140692.44
// Config block uses " = " (equals) separators, e.g.:
//   ; filament_type = PETG;PLA;PLA
//   ; filament_vendor = "Bambu Lab";"Bambu Lab"
function parseBambuStyle(text: string): Partial<GcodeParseResult> {
  const result: Partial<GcodeParseResult> = {};

  // First try PrusaSlicer-style comments (Bambu Studio uses many of these)
  const prusaResult = parsePrusaStyle(text);
  Object.assign(result, prusaResult);

  // Bambu header: "; total filament weight [g] : 433.16" — direct grams (best source)
  if (!result.filamentGrams) {
    const weightMatch = text.match(/;\s*total filament weight \[g\]\s*:\s*([\d.]+)/);
    if (weightMatch) {
      result.filamentGrams = parseFloat(weightMatch[1]);
    }
  }

  // Bambu header: "; total estimated time: 8h 40m 22s" (colon separator)
  if (!result.printTimeHours) {
    const timeMatch = text.match(/;\s*total estimated time\s*:\s*(.+)/);
    if (timeMatch) {
      result.rawPrintTimeString = timeMatch[1].trim();
      result.printTimeHours = parseTimeString(timeMatch[1]);
    }
  }

  // Bambu header (older versions, no colon): "; total estimated time 6m 39s"
  if (!result.printTimeHours) {
    const timeMatch = text.match(/;\s*total estimated time\s+(\d+[hms].+)/);
    if (timeMatch) {
      result.rawPrintTimeString = timeMatch[1].trim();
      result.printTimeHours = parseTimeString(timeMatch[1]);
    }
  }

  // Bambu header: "; model printing time: 8h 34m 8s" (alternative time field)
  if (!result.printTimeHours) {
    const modelTimeMatch = text.match(/;\s*model printing time\s*:\s*(.+)/);
    if (modelTimeMatch) {
      result.rawPrintTimeString = modelTimeMatch[1].trim();
      result.printTimeHours = parseTimeString(modelTimeMatch[1]);
    }
  }

  // Bambu header: "; total filament length [mm] : 140692.44" (colon separator)
  if (!result.filamentGrams && !result.rawFilamentLength) {
    const lengthMatch = text.match(/;\s*total filament length \[mm\]\s*:\s*([\d.]+)/);
    if (lengthMatch) {
      result.rawFilamentLength = parseFloat(lengthMatch[1]);
    }
  }

  // Bambu header (older versions, no colon): "; total filament length [mm] 35.16"
  if (!result.filamentGrams && !result.rawFilamentLength) {
    const lengthMatch = text.match(/;\s*total filament length \[mm\]\s+([\d.]+)/);
    if (lengthMatch) {
      result.rawFilamentLength = parseFloat(lengthMatch[1]);
    }
  }

  // Config block: "; filament_type = PETG;PLA;PLA" (first type is primary)
  if (!result.filamentType) {
    const typeMatch = text.match(/;\s*filament_type\s*=\s*([^\n]+)/);
    if (typeMatch) {
      // Multi-material: take first filament type (before semicolon)
      result.filamentType = typeMatch[1].trim().split(';')[0].trim();
    }
  }

  // Fallback: "; filament_type PLA" (no equals, older versions)
  if (!result.filamentType) {
    const typeMatch = text.match(/;\s*filament_type\s+(\S+)/);
    if (typeMatch) {
      result.filamentType = typeMatch[1].trim();
    }
  }

  // Config block: '; filament_vendor = "Bambu Lab";"Bambu Lab"'
  if (!result.filamentVendor) {
    const vendorMatch = text.match(/;\s*filament_vendor\s*=\s*"?([^";,\n]+)"?/);
    if (vendorMatch) {
      result.filamentVendor = vendorMatch[1].trim();
    }
  }

  // Config block: '; filament_settings_id = "Bambu PETG HF @BBL H2S";"Bambu PLA Matte @BBL H2S"'
  // More specific than filament_type — contains variant info like "HF", "Matte", etc.
  if (!result.filamentSettingsId) {
    const settingsMatch = text.match(/;\s*filament_settings_id\s*=\s*"?([^";]+)"?/);
    if (settingsMatch) {
      result.filamentSettingsId = settingsMatch[1].trim();
    }
  }

  return result;
}

// Parse Cura format
function parseCuraStyle(text: string): Partial<GcodeParseResult> {
  const result: Partial<GcodeParseResult> = {};

  // Time: ";TIME:5025" (in seconds)
  const timeMatch = text.match(/;TIME:(\d+)/);
  if (timeMatch) {
    const seconds = parseInt(timeMatch[1]);
    result.printTimeHours = Math.round((seconds / 3600) * 100) / 100;
    const h = Math.floor(seconds / 3600);
    const m = Math.floor((seconds % 3600) / 60);
    const s = seconds % 60;
    result.rawPrintTimeString = `${h}h ${m}m ${s}s`;
  }

  // Filament used: ";Filament used: 9.12345m" (in meters)
  const filamentMatch = text.match(/;Filament used:\s*([\d.]+)m/);
  if (filamentMatch) {
    const meters = parseFloat(filamentMatch[1]);
    result.rawFilamentLength = meters * 1000; // Convert to mm for storage
    // Don't convert to grams yet — we'll do that after detecting material type
  }

  // Material type: ";MATERIAL:PLA" (not always present)
  const materialMatch = text.match(/;MATERIAL:(\S+)/);
  if (materialMatch) {
    result.filamentType = materialMatch[1].trim();
  }

  // Alternative material from Cura settings comment block
  if (!result.filamentType) {
    const matMatch = text.match(/;material_type\s*=\s*(\S+)/);
    if (matMatch) {
      result.filamentType = matMatch[1].trim();
    }
  }

  return result;
}

// Parse IdeaMaker format
function parseIdeaMakerStyle(text: string): Partial<GcodeParseResult> {
  const result: Partial<GcodeParseResult> = {};

  // IdeaMaker: ";Filament length: 1234.5 mm"
  const lengthMatch = text.match(/;Filament length:\s*([\d.]+)\s*mm/i);
  if (lengthMatch) {
    result.rawFilamentLength = parseFloat(lengthMatch[1]);
  }

  // IdeaMaker: ";Filament weight: 24.5 g"
  const weightMatch = text.match(/;Filament weight:\s*([\d.]+)\s*g/i);
  if (weightMatch) {
    result.filamentGrams = parseFloat(weightMatch[1]);
  }

  // IdeaMaker: ";Print time: 1 hours 23 minutes"
  const timeMatch = text.match(/;Print time:\s*(.+)/i);
  if (timeMatch) {
    result.rawPrintTimeString = timeMatch[1].trim();
    const hoursMatch = timeMatch[1].match(/(\d+)\s*hours?/i);
    const minsMatch = timeMatch[1].match(/(\d+)\s*minutes?/i);
    let totalHours = 0;
    if (hoursMatch) totalHours += parseInt(hoursMatch[1]);
    if (minsMatch) totalHours += parseInt(minsMatch[1]) / 60;
    result.printTimeHours = Math.round(totalHours * 100) / 100;
  }

  // IdeaMaker: ";Filament Type: PLA"
  const typeMatch = text.match(/;Filament Type:\s*(\S+)/i);
  if (typeMatch) {
    result.filamentType = typeMatch[1].trim();
  }

  return result;
}

// Main parse function
// Reads only the first and last portions of the file (header + footer)
// to avoid processing entire multi-MB G-code files
export function parseGcode(content: string): GcodeParseResult {
  // Normalize line endings (Windows \r\n → \n) before splitting
  const normalized = content.replace(/\r\n/g, '\n');

  // Take first ~500 lines and last ~100 lines where metadata lives
  // Bambu Studio puts a large CONFIG_BLOCK after the HEADER_BLOCK that can be 300+ lines
  const lines = normalized.split('\n');
  const headerLines = lines.slice(0, 500).join('\n');
  const footerLines = lines.slice(-100).join('\n');
  const searchText = headerLines + '\n' + footerLines;

  const slicer = detectSlicer(searchText);

  let parsed: Partial<GcodeParseResult> = {};

  switch (slicer) {
    case 'bambu':
      parsed = parseBambuStyle(searchText);
      break;
    case 'prusa':
    case 'superslicer':
    case 'orca':
      parsed = parsePrusaStyle(searchText);
      break;
    case 'cura':
      parsed = parseCuraStyle(searchText);
      break;
    case 'ideamaker':
      parsed = parseIdeaMakerStyle(searchText);
      break;
    default:
      // Try all parsers and use whichever finds data
      parsed = parsePrusaStyle(searchText);
      if (!parsed.filamentGrams && !parsed.printTimeHours) {
        parsed = parseCuraStyle(searchText);
      }
      if (!parsed.filamentGrams && !parsed.printTimeHours) {
        parsed = parseBambuStyle(searchText);
      }
      if (!parsed.filamentGrams && !parsed.printTimeHours) {
        parsed = parseIdeaMakerStyle(searchText);
      }
      break;
  }

  // Convert length to grams if we have length but no grams
  let filamentGrams = parsed.filamentGrams ?? null;
  if (!filamentGrams && parsed.rawFilamentLength) {
    const density = getMaterialDensity(parsed.filamentType ?? null);
    filamentGrams = filamentLengthToGrams(parsed.rawFilamentLength, 1.75, density);
  }

  return {
    filamentGrams,
    printTimeHours: parsed.printTimeHours ?? null,
    filamentType: parsed.filamentType ?? null,
    filamentVendor: parsed.filamentVendor ?? null,
    filamentSettingsId: parsed.filamentSettingsId ?? null,
    slicer,
    rawFilamentLength: parsed.rawFilamentLength,
    rawPrintTimeString: parsed.rawPrintTimeString,
  };
}

// Normalize a filament type string from G-code to match our FilamentType union
// e.g., "PLA Basic" → "PLA", "PETG HF" → "PETG HF", "Bambu PLA-CF" → "PLA-CF"
const FILAMENT_TYPE_MAP: Record<string, FilamentType> = {
  // PLA variants
  'pla': 'PLA',
  'pla basic': 'PLA',
  'pla+': 'PLA',
  'pla pro': 'PLA',
  'pla matte': 'PLA Matte',
  'pla silk': 'PLA Silk',
  'pla silk+': 'PLA Silk',
  'pla tough': 'PLA Tough',
  'pla tough+': 'PLA Tough',
  'pla-cf': 'PLA-CF',
  'pla cf': 'PLA-CF',
  'pla translucent': 'PLA Translucent',
  'pla sparkle': 'PLA',
  'pla metal': 'PLA',
  'pla marble': 'PLA',
  'pla galaxy': 'PLA',
  'pla wood': 'PLA',
  'pla glow': 'PLA',
  'pla gradient': 'PLA',
  'pla aero': 'PLA',
  'pla silk multi-color': 'PLA Silk',
  // PETG variants
  'petg': 'PETG',
  'petg basic': 'PETG',
  'petg hf': 'PETG HF',
  'petg-cf': 'PETG-CF',
  'petg cf': 'PETG-CF',
  'petg translucent': 'PETG Translucent',
  'pet-cf': 'PETG-CF',
  // ABS / ASA
  'abs': 'ABS',
  'abs-gf': 'ABS',
  'asa': 'ASA',
  'asa-cf': 'ASA',
  'asa aero': 'ASA',
  // TPU
  'tpu': 'TPU',
  'tpu 95a': 'TPU 95A',
  'tpu 95a hf': 'TPU 95A',
  'tpu 85a': 'TPU 85A',
  'tpu 90a': 'TPU 85A', // Closest match
  'tpu for ams': 'TPU',
  // Nylon / PA
  'pa': 'PA6-CF',
  'pa6-cf': 'PA6-CF',
  'pa6 cf': 'PA6-CF',
  'paht-cf': 'PA6-CF', // Closest match
  'pa6-gf': 'PA6-CF', // Closest match
  'ppa-cf': 'PPA-CF',
  'ppa cf': 'PPA-CF',
  'nylon': 'PA6-CF',
  // PC
  'pc': 'PC',
  'pc fr': 'PC',
  // PVA
  'pva': 'PVA',
  // Support materials
  'support for pla': 'PVA',
  'support for petg': 'PVA',
  'support for pla/petg': 'PVA',
  'support for pa/pet': 'PVA',
  'support for abs': 'PVA',
};

export function matchFilamentType(parsedType: string, filamentSettingsId?: string | null): FilamentType | null {
  if (!parsedType) return null;

  // Try filament_settings_id first — it's more specific than filament_type
  // e.g. "Bambu PETG HF @BBL H2S" → "PETG HF" vs filament_type "PETG"
  if (filamentSettingsId) {
    const settingsNorm = filamentSettingsId
      .toLowerCase()
      .replace(/@.*/i, '')  // Remove printer suffix like "@BBL H2S"
      .replace(/^bambu\s+/i, '')
      .replace(/^generic\s+/i, '')
      .trim();

    if (FILAMENT_TYPE_MAP[settingsNorm]) {
      return FILAMENT_TYPE_MAP[settingsNorm];
    }

    // Try partial match on settings id
    for (const [key, value] of Object.entries(FILAMENT_TYPE_MAP)) {
      if (settingsNorm.startsWith(key) || key.startsWith(settingsNorm)) {
        return value;
      }
    }
  }

  const normalized = parsedType.toLowerCase().trim();

  // Direct lookup
  if (FILAMENT_TYPE_MAP[normalized]) {
    return FILAMENT_TYPE_MAP[normalized];
  }

  // Strip common brand prefixes and try again
  const stripped = normalized
    .replace(/^bambu\s+/i, '')
    .replace(/^generic\s+/i, '')
    .replace(/^polymaker\s+/i, '')
    .replace(/^esun\s+/i, '')
    .replace(/^hatchbox\s+/i, '')
    .replace(/^overture\s+/i, '')
    .replace(/^prusament\s+/i, '')
    .trim();

  if (FILAMENT_TYPE_MAP[stripped]) {
    return FILAMENT_TYPE_MAP[stripped];
  }

  // Partial matching — check if our type starts with a known key
  for (const [key, value] of Object.entries(FILAMENT_TYPE_MAP)) {
    if (stripped.startsWith(key) || key.startsWith(stripped)) {
      return value;
    }
  }

  // Last resort: check for base material keywords
  if (/\bpla\b/i.test(stripped)) return 'PLA';
  if (/\bpetg\b/i.test(stripped)) return 'PETG';
  if (/\babs\b/i.test(stripped)) return 'ABS';
  if (/\basa\b/i.test(stripped)) return 'ASA';
  if (/\btpu\b/i.test(stripped)) return 'TPU';
  if (/\bpa\b/i.test(stripped) || /\bnylon\b/i.test(stripped)) return 'PA6-CF';
  if (/\bpc\b/i.test(stripped)) return 'PC';
  if (/\bpva\b/i.test(stripped)) return 'PVA';

  return 'Other';
}

// Find the best matching filament Asset from the user's library
export function findBestFilamentMatch(
  parsedType: string | null,
  parsedVendor: string | null,
  assets: Asset[],
  filamentSettingsId?: string | null
): string | null {
  if (!parsedType) return null;

  const matchedType = matchFilamentType(parsedType, filamentSettingsId);
  if (!matchedType) return null;

  // Filter to filament assets only
  const filamentAssets = assets.filter(a => a.category === 'filament');
  if (filamentAssets.length === 0) return null;

  // Filter by matching filament type
  const typeMatches = filamentAssets.filter(a => a.filamentType === matchedType);
  if (typeMatches.length === 0) {
    // No exact type match — return first filament as fallback? No, return null
    return null;
  }

  if (typeMatches.length === 1) {
    return typeMatches[0].id;
  }

  // Multiple matches — prefer same brand
  if (parsedVendor) {
    const vendorNormalized = parsedVendor.toLowerCase().trim();
    const brandMatch = typeMatches.find(a =>
      a.brand?.toLowerCase().trim() === vendorNormalized
    );
    if (brandMatch) return brandMatch.id;

    // Fuzzy brand match (e.g., "Bambu Lab" matches "Bambu")
    const fuzzyBrandMatch = typeMatches.find(a => {
      const brand = a.brand?.toLowerCase().trim() ?? '';
      return brand.includes(vendorNormalized) || vendorNormalized.includes(brand);
    });
    if (fuzzyBrandMatch) return fuzzyBrandMatch.id;
  }

  // Return first type match
  return typeMatches[0].id;
}

// Read a G-code file efficiently (only header + footer)
export async function readGcodeFile(file: File): Promise<string> {
  const MAX_HEADER_BYTES = 50_000; // ~50KB for header (plenty for metadata)
  const MAX_FOOTER_BYTES = 20_000; // ~20KB for footer

  if (file.size <= MAX_HEADER_BYTES + MAX_FOOTER_BYTES) {
    // Small file — read entirely
    return file.text();
  }

  // Large file — read header and footer only
  const headerBlob = file.slice(0, MAX_HEADER_BYTES);
  const footerBlob = file.slice(file.size - MAX_FOOTER_BYTES);

  const [header, footer] = await Promise.all([
    headerBlob.text(),
    footerBlob.text(),
  ]);

  return header + '\n' + footer;
}
